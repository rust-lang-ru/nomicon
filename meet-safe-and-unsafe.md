% Встреча безопасного и небезопасного

Программисты безопасных "высокоуровневых" языков встречаются с фундаментальной
дилеммой. С одной стороны, было бы *очень* здорово сказать, что ты хочешь и не
переживать, как это сделается. С другой стороны это может привести к неприемлемо
низкой производительности. Может понадобится спуститься к менее понятным или
идиоматичным практикам, чтобы добиться лучшей производительности. Или может вы
брезгливо отдерните руки от высокоуровневого языка и решите раскошелиться на
реализацию на менее приторно-сладком *небезопасном* языке.

Еще хуже, если вы хотите иметь дело напрямую с операционной системой, вам
*придется* разговаривать на небезопасном языке: *Си*. Си вездесущ и неизбежен.
Это лингва-франка мира программирования. Даже все безопасные языки на самом деле
используют интерфейсы Си для общения с глобальным миром! Как бы вы ни хотели,
как только ваша программа начинает взаимодействовать с Си, она перестает быть
безопасной.

Имея это ввиду, надо сказать, что Rust *абсолютно* безопасный язык
программирования.

Ну, вообще-то, у Rust *есть* безопасный язык программирования. Сделаем небольшое 
отступление.

Rust можно считать состоящим из двух языков программирования: *Безопасный Rust*
и *Небезопасный Rust*. Безопасный Rust ваще, полностью безопасен.
Неудивительно, что небезопасный Rust ваще, полностью *не* безопасен.
Небезопасный Rust позволяет вам делать разные сумасшедшие небезопасные вещи.

Безопасный Rust это и *есть* язык программирования Rust. Если вы пишете все на
Безопасном Rust, вам никогда не придется волноваться о безопасности типов или
безопасности памяти. Вы никогда не испытаете проблем с нулевым или висячим
указателем или всей этой чушью с неопределенным поведением.

*Это офигенно круто.*

Стандартная библиотека дает вам достаточно готовых утилит, позволяющих
писать высокопроизводительные приложения или библиотеки на чистом
идиоматичном Безопасном Rust.

Но может вам захочется поговорить на другом языке. Может вы пишите низкоуровневые
абстракции, не включенные в стандартную библиотеку. Может вы просто
*пишете* стандартную библиотеку (которая написана полностью на Rust). Может вам
нужно сделать то, что не понимает система типов, и просто *программку из
чертовских бит*. Может вам нужен Небезопасный Rust.

Небезопасный Rust это тот же Безопасный Rust с теми же правилами и семантикой.
Но он позволяет делать вам некоторые дополнительные штуки, которые Определенно
Не Безопасны.

Единственные отличия Небезопасного Rust в том, что вы можете:

* Разыменовывать сырые указатели
* Вызывать `unsafe` функции (включая функции на Си, встроенные функции, 
сырое распределение)
* Реализовывать `unsafe` типажи 
* Изменять статические переменные

Вот и все. Причиной, по которой эти операции понижены до Небезопасных, является
то, что злоупотребление ими вызывает еще более Неопределенное Поведение. Вызов
Неопределенного поведения дает компилятору все права самовольно делать плохие
вещи с вашей программой. Вы определенно *не* должны вызывать Неопределенное
поведение.

В отличие от Си, Неопределенное поведение довольно ограничено в области Rust. Все
о чем заботиться ядро языка - предотвращение следующего:

* Разыменование нулевых или висячих указателей
* Чтение [неинициализированной памяти]
* Нарушение [правил выдачи псевдонимов указателям]
* Создание неверных примитивных значений:
    * висячих/нулевых ссылок
    * `bool`, который не 0 и не 1
    * неопределенных вариантов `enum`
    * `char` вне границ [0x0, 0xD7FF] и [0xE000, 0x10FFFF]
    * Не-utf8 `str`
* Размотка (unwinding)
* Вызов [гонок данных][race]

Вот и все. Это все случаи Неопределенного поведения применительно к Rust.
Конечно, небезопасные функции и типажи могут спокойно сами определять другие
ограничения, которые должны соблюдаться в программе для избежания
Неопределенного поведения. Однако смысл их все равно сведется к одной из проблем
выше. Некоторые дополнительные ограничения могут появиться из встроенных функций
компилятора, который делает предположения об оптимизации кода.

С другой стороны Rust довольно либерально относится к некоторым сомнительным
операциям. Rust считает "безопасными":

* Дедлоки
* Иметь [состояние гонки][race]
* Утечка памяти
* Невызванные деструкторы
* Переполнение целых чисел
* Прерывание программы
* Удаление рабочей базы данных

Однако любая программа, которая делает эти вещи, наверняка неправильна. Rust
предоставляет много инструментов для избавления от этих штук, но считаетстя, что
эти проблемы нельзя полностью предотвратить.

[pointer aliasing rules]: references.html
[uninitialized memory]: uninitialized.html
[race]: races.html
