% Владение и время жизни

Владение - это пробивная особенность Rust. Оно позволяет Rust быть полностью
безопасным по памяти и эффективным, избегая сборки мусора. Перед тем как
детально разобрать систему владения, мы объясним предпосылки такого дизайна.

Мы подразумеваем, что вы принимаете, что сборщик мусора - не всегда самое
оптимальное решение, и что желательно в некоторых случаях управлять памятью
вручную. Если вы это не принимаете, возможно, Rust не заинтересует вас.

Несмотря на ваши чувства к GC, он является *огромным* благом, позволяющим делать
код безопасным. Вам никогда не нужно волноваться, что некоторые вещи удалятся
*слишком рано* (хотя нужно ли вам по-прежнему иметь ссылку на них в этом случае
- это другой вопрос...). Это распространенная проблема, с которой приходится
иметь дело программам на C и C++. Посмотрите на эту простую ошибку, которую
каждый из  нас когда-то делал в языке без GC:

```rust,ignore
fn as_str(data: &u32) -> &str {
    // compute the string
    let s = format!("{}", data);

    // О НЕТ! Мы возвращаем ссылку на что-то, 
    // что существует только в этой функции!
    // Висячий указатель! Используется после освобождения! Увы и ах!
    // (Rust не компилирует этот код)
    &s
}
```

Вот что именно должна решать система владения в Rust. Rust знает область
видимости, в которой живет `&s`, и поэтому не даст выйти из нее. Однако это
простой случай, который, скорее всего, сможет поймать даже компилятор Си. Все
становится сложнее, когда код растет и указатели передаются в различные функции.
В конечном счете, компилятор Си не сможет выполнить анализ областей видимости,
чтобы доказать, что ваш код сломан. Ему придется заставить себя принять вашу
программу, предполагая, что она правильна.

Этого никогда не произойдет в Rust. Программист должен доказать компилятору, что
ничего не сломается.

Конечно, рассказ о владении в Rust гораздо сложнее, чем просто проверка, что
ссылка не выходит за область видимости того, на что она ссылается. Потому что 
доказать, что указатели всегда правильны, гораздо сложнее. Например, в этом коде

```rust,ignore
let mut data = vec![1, 2, 3];
// получаем внутреннюю ссылку
let x = &data[0];

// О НЕТ! `push` заставляет пересчитать занимаемое место `data`.
// Висячий указатель! Используется после освобождения! Увы и ах!
// (Rust не компилирует этот код)
data.push(4);

println!("{}", x);
```

обычный анализ областей видимости не сможет поймать ошибку, потому что
`data` на самом деле живет столько, сколько надо. Но она *поменялась* в то
время, когда у нас есть ссылка на нее. Вот поэтому Rust требует, чтобы любые
ссылки замораживали объекты, на которые ссылаются, и владельцев этих объектов.

