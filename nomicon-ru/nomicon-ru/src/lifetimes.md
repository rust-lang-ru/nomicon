% Время жизни

Rust проверяет соблюдение правил с помощью *времён жизни*. Время жизни - это
просто название областей видимости где-то в программе. Каждая ссылка, или то,
что содержит ссылки, помечается временем жизни, определяя область видимости, в
которой она правильна.

Внутри тела функции Rust обычно не позволяет вам явно назвать время жизни.
Потому что в общем случае в локальном контексте нет смысла говорить о времени
жизни; Rust обладает всей информацией и может обработать все достаточно
оптимально. Иначе вам пришлось бы создавать много анонимных областей и временных
переменных, просто чтобы заставить ваш код работать.

Но, когда вы переходите границы тела функции, вы должны начать говорить о
времени жизни. Время жизни обозначаются апострофами: `'a`, `'static`. Чтобы
окунуться во время жизни, мы сделаем вид, что нам разрешено помечать области
видимости временем жизни, и разберем пример из начала этой главы.

Изначально, наши примеры созданы с использованием *сильного* синтаксического
сахара -- с кукурузным сиропом с высоким содержанием фруктозы -- это касается
областей видимости и времен жизни, потому что написание всего этого в явной
форме *сильно замусоривает* код. Весь код Rust опирается на агрессивный вывод и
опускание "очевидных" вещей.

Первым особо интересным кусочком сахара является то, что каждое утверждение
`let` неявно объявляет область видимости. Для большинства случаев это абсолютно
не важно. Но это очень важно, когда переменные ссылаются друг на друга. В
качестве простого примера, давайте полностью избавимся от сахара в этом куске
кода на Rust:

```rust
let x = 0;
let y = &x;
let z = &y;
```

Анализатор заимствований всегда пытается минимизировать величину времени жизни,
поэтому скорее всего после избавления от сахара пример будет выглядеть так:

```rust,ignore
// Внимание: `'a: {` и `&'b x` это неправильный синтаксис!
'a: {
    let x: i32 = 0;
    'b: {
        // используемое время жизни 'b потому что его достаточно.
        let y: &'b i32 = &'b x;
        'c: {
            // то же самое с 'c
            let z: &'c &'b i32 = &'c y;
        }
    }
}
```

Ух ты! Это... ужасно. Давайте здесь остановимся и поблагодарим Rust за то, что
делает это проще.

На самом деле передача ссылок наружу из области видимости заставит Rust вывести
большее время жизни:

```rust
let x = 0;
let z;
let y = &x;
z = y;
```

```rust,ignore
'a: {
    let x: i32 = 0;
    'b: {
        let z: &'b i32;
        'c: {
            // Нужно использовать 'b здесь, потому что ссылка
            // передается снаружи в эту область видимости.
            let y: &'b i32 = &'b x;
            z = y;
        }
    }
}
```



# Пример: ссылки, которые переживают то, на что ссылаются

Отлично, давайте теперь посмотрим на некоторые примеры из тех, что были раньше:

```rust,ignore
fn as_str(data: &u32) -> &str {
    let s = format!("{}", data);
    &s
}
```

убрав сахар, получаем:

```rust,ignore
fn as_str<'a>(data: &'a u32) -> &'a str {
    'b: {
        let s = format!("{}", data);
        return &'a s;
    }
}
```

Сигнатура `as_str` берет ссылку на u32 с *каким-то* временем жизни, и обещает
создать ссылку на str, которая сможет жить *столько, сколько надо*. Мы уже
видели, почему такая сигнатура вызывает проблемы. Подразумевается, в принципе,
что мы собираемся использовать str в области видимости, в которой возникла
ссылка на u32 или *в еще большей области видимости*. Это уже задача потруднее.

Мы вычисляем строку `s`, и возвращаем ссылку на нее. По контракту нашей функции
ссылка должна пережить `'a`, поэтому это время жизни мы и подставим для нее. К
сожалению, `s` была определена в области видимости `'b`, поэтому единственный
вариант этого, если `'b` содержит `'a` -- что, очевидно, быть не может, ведь во
время жизни `'a` должен входить сам вызов функции. Таким образом мы создали
ссылку, чье время жизни превосходит время жизни того, на что она ссылается, а
это *буквально* первое, что мы сказали, что ссылки делать не могут. Компилятор
по праву взрывается перед нашими глазами.

Для лучшего объяснения расширим пример:

```rust,ignore
fn as_str<'a>(data: &'a u32) -> &'a str {
    'b: {
        let s = format!("{}", data);
        return &'a s
    }
}

fn main() {
    'c: {
        let x: u32 = 0;
        'd: {
            // Анонимная область видимости создается, потому что заимствование 
            // не обязано продолжаться на всю область видимости x. 
            // Возврат as_str должен найти str где-то раньше вызова
            // этой функции. Очевидно, что этого не произойдет.
            println!("{}", as_str::<'d>(&'d x));
        }
    }
}
```

Выстрел!

Конечно, правильно будет написать эту функцию так:

```rust
fn to_string(data: &u32) -> String {
    format!("{}", data)
}
```

Мы можем создать обладаемое значение внутри функции, чтобы вернуть его!
Единственный способ, которым мы могли бы вернуть `&'a str`, это если бы оно было
полем структуры `&'a u32`, но это явно не наш случай.

(Вообще, мы могли бы просто вернуть литеральную строку, которая, являясь
глобальным объектом, живет на дне стека; хотя это ограничит нашу реализацию
*немного*.)





# Пример: совпадение указателей у изменяемой ссылки

Как насчет другого примера:

```rust,ignore
let mut data = vec![1, 2, 3];
let x = &data[0];
data.push(4);
println!("{}", x);
```

```rust,ignore
'a: {
    let mut data: Vec<i32> = vec![1, 2, 3];
    'b: {
        // 'b длится столько, сколько нам нужно, чтобы длилось заимствование
        // (достаточно, чтобы добраться до  `println!`)
        let x: &'b i32 = Index::index::<'b>(&'b data, 0);
        'c: {
            // Временная область нужна, поскольку мы не хотим чтобы
            // &mut жила дольше.
            Vec::push(&'c mut data, 4);
        }
        println!("{}", x);
    }
}
```

Проблема здесь чуть тоньше и интересней. Мы хотим, чтобы Rust не принял эту
программу по следующей причине: у нас есть живая общая ссылка `x` на потомок
`data` в то время, когда мы пытаемся взять `data` как изменяемую ссылку и
выполнить `push`. Это приведет к созданию совпадающего указателя на изменяемую
ссылку, что нарушает *второе* правило ссылок.

Однако, *совсем не по этой причине* Rust считает, что программа неверна. Rust не
понимает, что  `x` - это ссылка на под-путь к `data`. Он абсолютно не понимает
Vec. Все, что он *видит*, это то, что `x` должен жить время `'b`, чтобы
его можно было напечатать. Дальше сигнатура `Index::index` требует, чтобы ссылка
по которой мы берем `data`, была живой в течение времени `'b`.  Когда мы
пытаемся вызвать `push`, компилятор видит, что мы пытаемся сделать `&'c mut
data`. Rust знает, что  `'c` содержится внутри `'b`, и отказывается принимать
нашу программу, потому что `&'b data` все еще жива к этому моменту!

Мы видим, что система времен жизни гораздо грубее, чем ссылочная семантика, в
сохранении которой мы на самом деле заинтересованы. Для большинства случаев,
*так совершенно нормально*, потому что позволяет не проводить целый день,
объясняя нашу программу компилятору. Но это означает, что некоторые абсолютно
правильные по семантике программы будут отвергнуты, из-за того что система
времен жизни слишком глупа.
