% Безграничные времена жизни

Небезопасный код часто может создавать ссылки или времена жизни из воздуха.
Такие времена рождаются *безграничными*. Основным источником этого является
разыменование сырого указателя, создающее ссылку с безграничным временем жизни.
Такое время устанавливается соответствующим контексту. На самом деле
оно даже мощнее, чем просто `'static`, потому что, например, `&'static &'a T` не
пройдет проверку типов, а безграничное время жизни спокойно превратится в `&'a
&'a T`, если это необходимо. Однако, в большинстве случаев, безграничное время
жизни можно рассматривать как `'static`.

У нас почти нет ссылок с временем жизни `'static`, поэтому, возможно, последнее
утверждение и неверно. `transmute` и`transmute_copy` являются двумя другими
основными нарушителями этого. Следует прилагать все усилия, чтобы как можно
быстрее ограничить такие безграничные времена жизни, в особенности это касается
пересечения границ функций.

В описании функции любые времена жизни на выходе, которые нельзя вывести
из времен на входе, будут безграничными. Например:

```rust,ignore
fn get_str<'a>() -> &'a str;
```

создаст `&str` с безграничным временем жизни. Самым простым способом избежать
этого будет использовать опускание времени жизни на границе функции. Если время жизни на выходе
опущено, то оно *должно* быть ограничено временем жизни на входе. Конечно,
возможно, оно будет ограничено *неправильно*, но это скорее вызовет просто
ошибку компиляции, но не нарушит безопасность памяти.

Внутри функции ограниченные времена жизни больше подвержены ошибкам. Самым
безопасным и простым способом ограничить время жизни будет вернуть его из
функции с ограниченным временем жизни. Но, если это невозможно, то ссылку можно
разместить в позиции, у которого указано конкретное время жизни. К сожалению,
невозможно именовать все времена жизни используемые внутри функции.
