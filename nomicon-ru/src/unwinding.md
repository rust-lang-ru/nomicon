% Размотка

У Rust *многоуровневая* схема перехвата ошибок:

* Если чего-то разумно не может быть, используется Option.
* Если что-то идет не так и может быть разумно перехвачено, используется Result.
* Если что-то идет не так и не может быть разумно перехвачено, поток паникует.
* Если что-то катастрофическое случается, программа закрывается с ошибкой.

Option и Result предпочитаемы в подавляющем большинстве ситуаций, особенно из-за
того, что они могут быть преобразованы в панику или прерывание с ошибкой по
усмотрению пользовательского API. Паника заставляет поток прервать нормальное
выполнение и размотать свой стек, вызывая деструкторы так, как-будто каждая
функция в стеке нормально завершилась.

По состоянию на 1.0, у Rust есть два мнения, когда дело доходит до паники.
Давным давно Rust был очень похож на Erlang. Как и у Erlang, у Rust были
легковесные потоки, и они должны были убивать себя с паникой, когда переходили
в неприемлемое состояние. В отличие от исключений в Java или C++, панику нельзя
было поймать в любое время. Ее мог поймать только владелец потока в
определенном месте перехвата или *и этот* поток начинал паниковать.

Размотка была очень важна в этом рассказе, потому что не вызов деструкторов
позволял утекать памяти и другим ресурсам системы. Из-за того, что ожидалось,
что потоки будут умирать во время нормального выполнения, Rust становился очень
слабым при работе с долго-живущими системами!

Rust, каким мы его знаем сейчас, вырос из стиля программирования в виде создания
все меньших-и-меньших абстракций. Легковесные потоки были убиты и заменены на
тяжеловесные потоки ОС. Однако, на стабильном Rust 1.0 паники могут
перехватываться только родительским потоком. Это означает, что поимка паники
требует размотки целого потока ОС! Это, к сожалению, идет в разрез с философией
Rust - использование абстракций нулевой стоимости.

Существует нестабильное API, называемое `catch_panic`, которое позволяет ловить
панику, не порождая поток. По-прежнему, мы просим вас пользоваться им умеренно.
В частности, текущая реализация размотки в Rust сильно оптимизирована под
"невыполняющие размотку" случаи. Если программа не выполняет размотку, цена
*ожидания* размотки является нулевой во время исполнения. Как следствие, текущая
версия размотки является более дорогостоящей, чем, например, в Java. Не стройте
программы, использующие размотку в обычных ситуациях. В идеале вы должны
вызывать панику только в случае программных ошибок или *огромных* проблем.

Стратегия размотки в Rust не заточена под полную совместимость с размоткой в
других языках. Поэтому размотка в Rust из других языков или наоборот является
Неопределенным Поведением. Вы должны ловить *абсолютно* все паники на границе
FFI! Что конкретно вы будете делать, зависит от вас, но *что-то* делать надо
обязательно. Если вы ошибетесь с этим, лучшее, что произойдет, ваше приложение
сломается и сгорит. Худшее - оно *не* сломается и *не* сгорит, а продолжит
работать в полностью расколошмаченном состоянии.
