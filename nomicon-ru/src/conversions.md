# Преобразование типов

В конечном счёте, все является кучей бит, расположенных где-то, а система типов нужна, чтобы понять, что эти биты правильны. Существует две основных проблемы при типизации битов: необходимость интерпретировать эти биты в качестве другого типа и необходимость менять биты, чтобы получить эквивалентное значение другого типа. Из-за того, что Rust поддерживает кодировку важных свойств в системе типов, эти проблемы невероятно распространены. В связи с этим Rust даёт вам несколько способов их решения.

Сначала посмотрим на то, как Безопасный Rust может по-разному интерпретировать значения. Самый простой способ - разбить значение на части и потом из них собрать новое значение, например:

```rust
struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -> Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
```

Но это, в лучшем случае, утомительно. Для обычных преобразований Rust предоставляет более удобные альтернативы.
