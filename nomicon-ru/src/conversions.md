% Преобразование типов

В конечном счете, все является кучей бит, расположенных где-то, а система типов
нужна, чтобы понять, что эти биты правильны. Существует две основных проблемы
при типизации битов: необходимость интерпретировать эти биты в качестве другого
типа и необходимость менять биты, чтобы получить эквивалентное значение другого
типа. Из-за того, что Rust поддерживает кодировку важных свойств в системе
типов, эти проблемы невероятно распространены. В связи с этим Rust дает вам
несколько способов их решения.

Сначала посмотрим на то, как Безопасный Rust может по-разному интерпретировать
значения. Самый простой способ - разбить значение на части и потом из них
собрать новое значение, например:

```rust
struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -> Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
```

Но это, в лучшем случае, утомительно. Для обычных преобразований Rust
предоставляет более удобные альтернативы.

