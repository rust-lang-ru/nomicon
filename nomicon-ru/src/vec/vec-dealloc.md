# Освобождение

Следующее, что мы должны сделать - это реализовать Drop так, чтобы у нас не происходила широкомасштабная утечка кучи ресурсов. Самым простым способом будет вызывать `pop` до тех пор пока он не вернет None, и затем освободить наш буфер. Помните, что вызов `pop` не нужен, если `T: !Drop`. В теории мы можем спросить у Rust, является ли `T` `needs_drop` и избежать вызова `pop`. Однако, на практике, LLVM *действительно* хорош в удалении такого простого независимого кода без побочных эффектов, поэтому я бы не стал беспокоится, если только вы не заметите, что он не удален (в этом случае он будет удален).

Мы не должны вызывать `heap::deallocate`, если `self.cap == 0`, так как в этом случае мы еще на самом деле не выделили память.

<!-- ignore: simplified code -->

```rust,ignore
impl<T> Drop for Vec<T> {
    fn drop(&mut self) {
        if self.cap != 0 {
            while let Some(_) = self.pop() { }
            let layout = Layout::array::<T>(self.cap).unwrap();
            unsafe {
                alloc::dealloc(self.ptr.as_ptr() as *mut u8, layout);
            }
        }
    }
}
```
