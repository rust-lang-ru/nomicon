% Трансмутации

Уберись с нашей дороги, система типов! Мы будем интерпретировать эти биты по-
своему или умрем пытаясь! Хотя эта книга и про создание небезопасных вещей, я
действительно не могу не подчеркнуть, что вы должны глубоко задуматься над
поиском Другого способа, кроме того, что рассматривается в этом разделе. Это
действительно, по-настоящему, самая ужасно небезопасная вещь, которую вы можете
сделать в Rust. Это как если бы железнодорожное полотно охраняла зубная нить.

`mem::transmute<T, U>` берет значение типа `T` и интерпретирует его, как тип `U`. 
Единственное ограничение - размер `T` и `U` должен совпадать. Варианты, которые 
вызывают Неопределенное Поведение этим, сводят с ума.

* Первое и самое главное, создание экземпляра *любого* типа с неправильным 
состоянием вызовет огромный хаос, который невозможно будет предсказать.
* Трансмутация имеет перегруженный тип возврата. Если вы не укажете тип возврата
 она создаст какой-то неизвестный тип, удовлетворяющий выводу типов.
* Создание примитива с неправильным значением - это неопределённое поведение (НП)
* Трансмутации между non-repr(C) типами - это НП
* Трансмутации & в &mut - это НП
    * Трансмутации & в &mut - это *всегда* НП!
    * Нет, ты не можешь так делать!
    * Нет, ты не особенный!
* Трансмутации в ссылку без явного указания времени жизни создает [unbounded-lifetimes]

`mem::transmute_copy<T, U>` каким-то образом стал *даже более дико* небезопасным
 чем это. Он копирует `size_of<U>` байтов из `&T` и интерпретирует их как `U`. 
 Проверка длины, которая была у `mem::transmute` пропала (потому что копировать 
 префикс может оказаться допустимым), хотя если `U` длиннее, чем `T` - это 
  Неопределенное Поведение.

Вы можете получить большую часть этой функциональности, используя явное
приведение указателей.


[unbounded-lifetimes]: unbounded-lifetimes.md
