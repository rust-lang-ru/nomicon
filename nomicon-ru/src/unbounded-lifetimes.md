# Безграничные времена жизни

Небезопасный код часто может создавать ссылки или времена жизни из воздуха. Такие времена рождаются *безграничными*. Основным источником этого является разыменование сырого указателя, создающее ссылку с безграничным временем жизни. Такое время устанавливается соответствующим контексту. На самом деле оно даже мощнее, чем просто `'static`, потому что, например, `&'static &'a T` не пройдет проверку типов, а безграничное время жизни спокойно превратится в `&'a &'a T`, если это необходимо. Однако, в большинстве случаев, безграничное время жизни можно рассматривать как `'static`.

У нас почти нет ссылок с временем жизни `'static`, поэтому, возможно, последнее утверждение и неверно. `transmute` и`transmute_copy` являются двумя другими основными нарушителями этого. Следует прилагать все усилия, чтобы как можно быстрее ограничить такие безграничные времена жизни, в особенности это касается пересечения границ функций.

В описании функции любые времена жизни на выходе, которые нельзя вывести из времен на входе, будут безграничными. Например:

<!-- ignore: simplified code -->

```rust,ignore
fn get_str<'a>() -> &'a str;
```

создаст `&str` с безграничным временем жизни. Самым простым способом избежать этого будет использовать опускание времени жизни на границе функции. Если время жизни на выходе опущено, то оно *должно* быть ограничено временем жизни на входе. Конечно, возможно, оно будет ограничено *неправильно*, но это скорее вызовет просто ошибку компиляции, но не нарушит безопасность памяти.

Внутри функции ограниченные времена жизни больше подвержены ошибкам. Самым безопасным и простым способом ограничить время жизни будет вернуть его из функции с ограниченным временем жизни. Но, если это невозможно, то ссылку можно разместить в позиции, у которого указано конкретное время жизни. К сожалению, невозможно именовать все времена жизни используемые внутри функции.
